"use strict";(self.webpackChunkdropit=self.webpackChunkdropit||[]).push([[230],{3888:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var o=n(4848),i=n(8453);const s={},a="Lifetime",r={id:"vision/lifetime",title:"Lifetime",description:"DropIt is unique in the Polkadot ecosystem in that it is designed to be ephemeral.",source:"@site/docs/vision/lifetime.md",sourceDirName:"vision",slug:"/vision/lifetime",permalink:"/docs/vision/lifetime",draft:!1,unlisted:!1,editUrl:"https://github.com/polkadot-dropit/docs/tree/main/packages/create-docusaurus/templates/shared/docs/vision/lifetime.md",tags:[],version:"current",frontMatter:{},sidebar:"docSidebar",previous:{title:"Governance",permalink:"/docs/vision/governance"},next:{title:"Utility",permalink:"/docs/category/utility"}},l={},h=[{value:"State Bloat",id:"state-bloat",level:2},{value:"Storage Deposits",id:"storage-deposits",level:2},{value:"Existential Deposit",id:"existential-deposit",level:3},{value:"Ramifications of Storage Deposits",id:"ramifications-of-storage-deposits",level:3},{value:"Disposable Parachains",id:"disposable-parachains",level:2},{value:"Data Sharding",id:"data-sharding",level:3},{value:"Parachain Footprint",id:"parachain-footprint",level:3},{value:"Disposing",id:"disposing",level:3},{value:"Token Migration",id:"token-migration",level:3}];function c(e){const t={a:"a",blockquote:"blockquote",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"lifetime",children:"Lifetime"}),"\n",(0,o.jsxs)(t.p,{children:["DropIt is unique in the Polkadot ecosystem in that it is designed to be ",(0,o.jsx)(t.strong,{children:"ephemeral"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Whereas most parachains take careful consideration to ensure their chain can scale and persist over time, DropIt will be designed to grow fast and without concern for the far future."}),"\n",(0,o.jsx)(t.p,{children:"To understand what this means, you need to understand a few topics."}),"\n",(0,o.jsx)(t.h2,{id:"state-bloat",children:"State Bloat"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://www.techopedia.com/definition/blockchain-bloat",children:"State bloat"})," is one of the key long term scaling issues of blockchain systems. As the chain grows, accessing items in the database become more complex due to the construction of the Merkle trie. Also running a full node for the chain becomes more expensive as more storage space is needed to keep the current state of the chain."]}),"\n",(0,o.jsxs)(t.p,{children:["Chains like Ethereum are plagued with ",(0,o.jsx)(t.a,{href:"https://github.com/ethereum/EIPs/issues/168",children:'"dust accounts"'})," whose balance is lower than the cost of transaction fees needed to move those balances. Thus these accounts will likely congest the network's Merkle trie forever, and result in a decrease of performance and an increase of costs when running nodes."]}),"\n",(0,o.jsx)(t.p,{children:'Ethereum also faces state scaling issues related to the presence of unused smart contracts and smart contract state. For example, when users push a "Hello, World!" smart contract to Ethereum, they pay a one time fee at the time of the contract deployment, but then those contracts live in the chain state forever, even when they are not being used.'}),"\n",(0,o.jsx)(t.h2,{id:"storage-deposits",children:"Storage Deposits"}),"\n",(0,o.jsx)(t.p,{children:"Chains in the Polkadot ecosystem address this issue through the introduction of storage deposits."}),"\n",(0,o.jsx)(t.p,{children:"A storage deposit is where users are asked to reserve some amount of token whenever they place data on the blockchain. This deposit cannot be transferred or used while it is reserved. When using an inflationary token like DOT, having a storage deposit is an opportunity cost comparing the value of having that data on chain and gaining interest on the token through staking rewards."}),"\n",(0,o.jsx)(t.p,{children:"Thus, users are incentivized to clean up data from the blockchain to remove useless data and in order to get their deposit back."}),"\n",(0,o.jsx)(t.h3,{id:"existential-deposit",children:"Existential Deposit"}),"\n",(0,o.jsx)(t.p,{children:"Existential Deposit is a minimum balance that an account needs to hold in order to maintain a presence on the blockchain. The existential deposit is just a storage deposit for the base data needed for each account. For example:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Nonce"}),"\n",(0,o.jsx)(t.li,{children:"Balance"}),"\n",(0,o.jsx)(t.li,{children:"Reference Counters"}),"\n",(0,o.jsx)(t.li,{children:"etc..."}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"ramifications-of-storage-deposits",children:"Ramifications of Storage Deposits"}),"\n",(0,o.jsx)(t.p,{children:"Storage deposits ultimately protect the long term growth of a chain, but also creates overhead for using the chain."}),"\n",(0,o.jsx)(t.p,{children:"Especially in the context of parachains on Polkadot, even if a user has an existential deposit on Polkadot, they also need to establish an existential deposit on the parachain to use it."}),"\n",(0,o.jsx)(t.p,{children:"Similarly, the creation and distribution of secondary tokens on chains with an existential deposit are usually prohibitive. In general, this is a good behavior to protect the chain from spam and useless data, but in the current blockchain landscape, this usually limits adoption."}),"\n",(0,o.jsx)(t.p,{children:"Many other blockchains subsidize the costs of their chain and don't consider long term growth and maintenance in order to specifically bootstrap activity."}),"\n",(0,o.jsx)(t.h2,{id:"disposable-parachains",children:"Disposable Parachains"}),"\n",(0,o.jsx)(t.p,{children:"Polkadot is uniquely capable of supporting chains without consideration for storage deposits through the creation of disposable parachains."}),"\n",(0,o.jsx)(t.p,{children:'TODO: perhaps reframe this concept from the term "disposable"'}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["See the original Polkadot Forum post: ",(0,o.jsx)(t.a,{href:"https://forum.polkadot.network/t/disposable-parachains-for-airdrops-and-other-ideas/5769",children:"Disposable Parachains (for Airdrops and other ideas)"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"data-sharding",children:"Data Sharding"}),"\n",(0,o.jsx)(t.p,{children:"Polkadot scales through data and execution sharding. In the context of state scaling, each parachain is responsible to host its own data, and present relevant data needed to execute a block to Polkadot in order for Polkadot to verify the validity of the block."}),"\n",(0,o.jsxs)(t.p,{children:["In the Polkadot ecosystem, the parachain state is maintained by parachain collators. Because collators do not provide any security to Polkadot or the parachain, they can be run by anyone. Only a single copy of the parachain state needs to exist in order to produce new blocks, which allows storage bloat to have a significantly lower impact to the overall network. See ",(0,o.jsx)(t.a,{href:"/docs/vision/block-production",children:"block production"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"parachain-footprint",children:"Parachain Footprint"}),"\n",(0,o.jsx)(t.p,{children:"Parachains on Polkadot do not replicate their full state on Polkadot. Instead, only the state root of DropIt is permanently stored on the relay chain."}),"\n",(0,o.jsx)(t.p,{children:"This means no matter how heavy or bloated DropIt becomes, the Polkadot itself will be unaffected."}),"\n",(0,o.jsx)(t.h3,{id:"disposing",children:"Disposing"}),"\n",(0,o.jsxs)(t.p,{children:["Since DropIt is designed without consideration for ",(0,o.jsx)(t.a,{href:"#state-bloat",children:"state bloat"}),", the cost for running nodes may increase rapidly."]}),"\n",(0,o.jsxs)(t.p,{children:["Because DropIt has completely permissionless and open ",(0,o.jsx)(t.a,{href:"/docs/vision/block-production",children:"block production"}),", it is up to the collators themselves to determine if it is valuable to continue to run the network."]}),"\n",(0,o.jsx)(t.p,{children:"When all potential collators decide they no longer want to run the network the chain will stop producing blocks. If in the future, anyone wants to submit new transactions to the chain, they can spin up their own collator and build a new block, assuming they can get access to the last finalized state."}),"\n",(0,o.jsx)(t.h3,{id:"token-migration",children:"Token Migration"}),"\n",(0,o.jsx)(t.p,{children:"Since DropIt is designed to be ephemeral, it is not suggested that tokens permanently live in the DropIt chain."}),"\n",(0,o.jsx)(t.p,{children:"When a token accrues enough value or importance to users, it is recommended that the token is teleported to permanent chains like the Polkadot's Asset Hub."}),"\n",(0,o.jsx)(t.p,{children:"In this case, users will need to establish an existential deposit to hold the token, but the user should find greater value in the token itself."}),"\n",(0,o.jsx)(t.p,{children:'Also, it is possible for the Polkadot Governance to make a token "sufficient", meaning that users would be able to hold the token on the Asset Hub without any existential deposit, however the barrier for these kinds of tokens are quite high.'})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(6540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);